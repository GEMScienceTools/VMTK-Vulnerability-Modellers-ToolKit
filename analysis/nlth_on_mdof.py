# -*- coding: utf-8 -*-
"""
Created on Fri Jan 17 08:55:51 2020

@author: LuisMartins
"""


import openseespy.opensees as ops
import numpy as np
import pandas as pd
import warnings
from scipy import optimize
#%%

def compute_modal_shape(gamma,n_storeys,storey_height=2.8):
    
    phi=np.zeros(n_storeys)
    total_height=n_storeys*storey_height
    
    storey_heights=[(i+1)*storey_height for i in range(n_storeys)]
        
    def func(x):
        
        for i in range(n_storeys):
            
            if i==(n_storeys-1):
                phi[i]=1.0
            else:
                phi[i]=x[i]
      
        computed_gamma=np.sum(phi)/np.sum(phi**2)        
        loss_squared=(gamma-computed_gamma)**2
        
        return loss_squared
           
    solution=optimize.fmin(func,[storey_heights[i]/total_height for i in range(n_storeys-1)],disp=False)
    
    for i in range(n_storeys):
        
        if i==(n_storeys-1):
            phi[i]=1.0
        else:
            phi[i]=solution[i]
    
    return phi
#%%

def compute_storey_force(total_base_shear,n_storeys,gamma,storey_height):
    
    # this function computes the lateral force at floor level assuming a distribution proportional to phi1
    # it outputs an array where node0=force at base (it is 0 always) and noden= force at top
    
    phi=compute_modal_shape(gamma,n_storeys,storey_height)
    
    ratios=np.concatenate([np.array([0]),phi])
    
    force_at_top_floor=total_base_shear/np.sum(ratios)
    
    nodal_lateral_forces=force_at_top_floor*ratios   
    
    return nodal_lateral_forces
#%%
   
def compute_M_at_floors(nodal_lateral_forces,n_storeys,storey_height):
    
    storey_heights=storey_height*np.linspace(start=0,
                                             stop=n_storeys,
                                             num=n_storeys+1,endpoint=True)
    
    nodal_moment_value=np.zeros(storey_heights.shape)
    
    for i in reversed(range(n_storeys)):
        
        nodal_moment_value[i]=np.sum(np.multiply(nodal_lateral_forces[i+1:],
                                                  storey_heights[i+1:]-storey_heights[i]))
    return nodal_moment_value
#%%

def compute_M_M_integral(L,M1,M2,M3,M4):
    
    # this computes the M-M' integral assuming a trapesoidal distribution
    
    # M1 M2 are the moments for M
    # M3 M4 are the moments for M'    
    
    return L/6*(M1*(2*M3+M4)+M2*(M3+2*M4))
#%%
   
def springs_parameters(n_storeys,capacity_curve_array,gamma,storey_height=2.8):
      
    roof_displacement_array=capacity_curve_array[:,0]*gamma
    base_shear_array=capacity_curve_array[:,1]*9.81*gamma
    
    # estimate different periods (i.e. T1, Ty, ...,Tult)
    periods_array=np.zeros(capacity_curve_array.shape[0]-1)
    
    for i in range(1,capacity_curve_array.shape[0]):
        
        periods_array[i-1]=np.sqrt((2*np.pi)**2/\
                        ((capacity_curve_array[i,1]*9.81)/capacity_curve_array[i,0]))
                 
    # multiplication factor to account for linear reduction of stiffness with height
    # K_storey=mult*K_constant

    b=((1-n_storeys**2)/(-1*n_storeys+1))
    m=(n_storeys-((1-n_storeys**2)/(-1*n_storeys+1)))
    
    stiff_storey_mult=[m*(i+1)+b for i in range(n_storeys)]
        
    # using the force method lets compute the EI value that leads to the roof displacement and base shear 
    # in the capacity curve (the lateral loads are assumed to be a triangular shape)
    # d_roof=1/EI*integral(M*M'dx)
    
    storey_heights=storey_height*np.linspace(start=0,
                                             stop=n_storeys,
                                             num=n_storeys+1,endpoint=True)
    
    springs_stiffness_matrix=np.zeros([capacity_curve_array.shape[0],n_storeys])
    
    for i in range(1,capacity_curve_array.shape[0]):
        
        lateral_loads=compute_storey_force(base_shear_array[i],n_storeys,gamma,storey_height)
        
        m_values=compute_M_at_floors(lateral_loads,n_storeys,storey_height)
        
        m_aux_values=compute_M_at_floors(np.array([0 if _<n_storeys else 1 for _ in range(n_storeys+1)]),
                                         n_storeys,storey_height)
        
        sum_accumulator=0
        
        for j in range(n_storeys):
            
            M1=m_values[j]
            M2=m_values[j+1]
            
            M3=m_aux_values[j]
            M4=m_aux_values[j+1]
            
            L=storey_heights[j+1]-storey_heights[j]
            
            integral=compute_M_M_integral(L,M1,M2,M3,M4)
            
            sum_accumulator+=(1/stiff_storey_mult[j])*integral
        
        EI=1/roof_displacement_array[i]*sum_accumulator
        
        springs_stiffness_matrix[i,:]=np.array(stiff_storey_mult)*EI
    
    return springs_stiffness_matrix,stiff_storey_mult,periods_array
#%%

def compute_nodal_displacements(springs_stiffness_matrix,nodal_lateral_forces,n_storeys,storey_height):
    
    
    
    
    return True 
#%%

def build_mdof_ops_py(n_storeys,capacity_curve,gamma,storey_height):
      
      cap_df=pd.DataFrame(capacity_curve)
      if any(cap_df.duplicated()):
            warnings.warn("Warning: Duplicated pairs have been found in capacity curve!")
            
      
      springs_stiffness_matrix,_,_,=springs_parameters(n_storeys,capacity_curve,
                                                          gamma,storey_height)
      
      roof_displacement_array=capacity_curve[:,0]*gamma
      base_shear_array=capacity_curve[:,1]*9.81*gamma
      
      phi=compute_modal_shape(gamma,n_storeys)
      
      if capacity_curve.shape[0]>=4:
                  
            sa=capacity_curve[2,1]*9.81
            sd=capacity_curve[2,0]

      else:
            sa=capacity_curve[1,1]*9.81
            sd=capacity_curve[1,0]
            
      ty=(2*np.pi)/(np.sqrt(sa/sd))
      
      ops.wipe()
      ops.model('basic','-ndm',1,'-ndf',1)
      
      m_star=((ty/(2*np.pi))**2)/(sd/sa)      
      mx=m_star/(np.sum(phi))
      
      # define model geometry
      for i in range(n_storeys+1):
          
          node_tag=int(i)
          if i:
              
              ops.node(node_tag,0,'-mass',float(mx))
          else: # base note (nodeTag=0)

              ops.node(node_tag,0)
              ops.fix(node_tag,1) # fix base node
     
           
      return True

#%%
def run_nlth_analysis_on_mdof_ops_py(n_storeys,capacity_curve,gamma,storey_height,gmr,damping,degradation):
    
    # build model
    build_mdof_ops_py(n_storeys,capacity_curve,gamma,storey_height)

    return True     
