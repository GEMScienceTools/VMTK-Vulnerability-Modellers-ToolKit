# -*- coding: utf-8 -*-
"""
Created on Fri Jan 17 08:55:51 2020

@author: LuisMartins
"""


import openseespy.opensees as ops
import numpy as np
import pandas as pd
import warnings
import os
from scipy import optimize
import matplotlib.pyplot as plt
#%%

def compute_modal_shape(gamma,n_storeys,storey_height=2.8):
    
    phi=np.zeros(n_storeys)
    total_height=n_storeys*storey_height
    
    storey_heights=[(i+1)*storey_height for i in range(n_storeys)]
        
    def func(x):
        
        for i in range(n_storeys):
            
            if i==(n_storeys-1):
                phi[i]=1.0
            else:
                phi[i]=x[i]
      
        computed_gamma=np.sum(phi)/np.sum(phi**2)        
        loss_squared=(gamma-computed_gamma)**2
        
        return loss_squared
           
    solution=optimize.fmin(func,[storey_heights[i]/total_height for i in range(n_storeys-1)],disp=False)
    
    for i in range(n_storeys):
        
        if i==(n_storeys-1):
            phi[i]=1.0
        else:
            phi[i]=solution[i]
    
    return phi



#%%

def compute_storey_force(total_base_shear,n_storeys,gamma,storey_height):
    
    # this function computes the lateral force at floor level assuming a distribution proportional to phi1
    # it outputs an array where node0=force at base (it is 0 always) and noden= force at top
    
    phi=compute_modal_shape(gamma,n_storeys,storey_height)
    
    ratios=np.concatenate([np.array([0]),phi])
    
    force_at_top_floor=total_base_shear/np.sum(ratios)
    
    nodal_lateral_forces=force_at_top_floor*ratios   
    
    return nodal_lateral_forces
#%%
   
def compute_M_at_floors(nodal_lateral_forces,n_storeys,storey_height):
    
    storey_heights=storey_height*np.linspace(start=0,
                                             stop=n_storeys,
                                             num=n_storeys+1,endpoint=True)
    
    nodal_moment_value=np.zeros(storey_heights.shape)
    
    for i in reversed(range(n_storeys)):
        
        nodal_moment_value[i]=np.sum(np.multiply(nodal_lateral_forces[i+1:],
                                                  storey_heights[i+1:]-storey_heights[i]))
    return nodal_moment_value
#%%

def compute_M_M_integral(L,M1,M2,M3,M4):
    
    # this computes the M-M' integral assuming a trapesoidal distribution
    
    # M1 M2 are the moments for M
    # M3 M4 are the moments for M'    
    
    return L/6*(M1*(2*M3+M4)+M2*(M3+2*M4))
#%%
   
def springs_parameters(n_storeys,capacity_curve_array,total_mass,gamma,storey_height=2.8):
      
    roof_displacement_array=capacity_curve_array[:,0]*gamma
    base_shear_array=capacity_curve_array[:,1]*9.81*total_mass*gamma
    
    # estimate different periods (i.e. T1, Ty, ...,Tult)
    periods_array=np.zeros(capacity_curve_array.shape[0]-1)
    
    for i in range(1,capacity_curve_array.shape[0]):
        
        periods_array[i-1]=np.sqrt((2*np.pi)**2/\
                        ((capacity_curve_array[i,1]*9.81)/capacity_curve_array[i,0]))
                 
    # multiplication factor to account for linear reduction of stiffness with height
    # K_storey=mult*K_constant

    b=((1-n_storeys**2)/(-1*n_storeys+1))
    m=(n_storeys-((1-n_storeys**2)/(-1*n_storeys+1)))
    
    stiff_storey_mult=[m*(i+1)+b for i in range(n_storeys)]
        
    # using the force method lets compute the EI value that leads to the roof displacement and base shear 
    # in the capacity curve (the lateral loads are assumed to be a triangular shape)
    # d_roof=1/EI*integral(M*M'dx)
    
    storey_heights=storey_height*np.linspace(start=0,
                                             stop=n_storeys,
                                             num=n_storeys+1,endpoint=True)
    
    springs_stiffness_matrix=np.zeros([capacity_curve_array.shape[0],n_storeys])
    
    for i in range(1,capacity_curve_array.shape[0]):
        
        lateral_loads=compute_storey_force(base_shear_array[i],n_storeys,gamma,storey_height)
        
        m_values=compute_M_at_floors(lateral_loads,n_storeys,storey_height)
        
        m_aux_values=compute_M_at_floors(np.array([0 if _<n_storeys else 1 for _ in range(n_storeys+1)]),
                                         n_storeys,storey_height)
        
        sum_accumulator=0
        
        for j in range(n_storeys):
            
            M1=m_values[j]
            M2=m_values[j+1]
            
            M3=m_aux_values[j]
            M4=m_aux_values[j+1]
            
            L=storey_heights[j+1]-storey_heights[j]
            
            integral=compute_M_M_integral(L,M1,M2,M3,M4)
            
            sum_accumulator+=(1/stiff_storey_mult[j])*integral
        
        EI=(1/roof_displacement_array[i])*sum_accumulator
        
        springs_stiffness_matrix[i,:]=np.array(stiff_storey_mult)*EI
    
    return springs_stiffness_matrix,stiff_storey_mult,periods_array
#%%

def compute_nodal_displacements(springs_stiffness_matrix,capacity_curve_array,total_mass,n_storeys,gamma,storey_height):
    
    nodal_displacement_matrix=np.zeros([capacity_curve_array.shape[0],n_storeys+1])
    
    storey_heights=storey_height*np.linspace(start=0,
                                             stop=n_storeys,
                                             num=n_storeys+1,endpoint=True)
    
    base_shear_array=capacity_curve_array[:,1]*9.81*total_mass*gamma
    
    for i in range(1,capacity_curve_array.shape[0]):
        
        lateral_loads=compute_storey_force(base_shear_array[i],n_storeys,gamma,storey_height)
        
        m_values=compute_M_at_floors(lateral_loads,n_storeys,storey_height)
        
        for j in range(n_storeys+1):
            
            m_aux_values=compute_M_at_floors(np.array([1 if _==j else 0 for _ in range(n_storeys+1)]),
                                             n_storeys,storey_height)
            
            sum_accumulator=0
            
            for k in range(n_storeys):
                
                M1=m_values[k]
                M2=m_values[k+1]
                
                M3=m_aux_values[k]
                M4=m_aux_values[k+1]
                
                L=storey_heights[k+1]-storey_heights[k]
                
                integral=compute_M_M_integral(L,M1,M2,M3,M4)
                
                EIk=springs_stiffness_matrix[i,k]
                
                sum_accumulator+=(1/EIk)*integral
                
            nodal_displacement_matrix[i,j]=sum_accumulator
            
    return nodal_displacement_matrix 
#%%

def build_test_mdof_ops_py(n_storeys,capacity_curve,gamma,storey_height,x):
      
      cap_df=pd.DataFrame(capacity_curve)
      if any(cap_df.duplicated()):
            warnings.warn("Warning: Duplicated pairs have been found in capacity curve!")

      phi=compute_modal_shape(gamma,n_storeys)
           
      if capacity_curve.shape[0]>=4:
                  
            say=capacity_curve[2,1]*9.81
            sdy=capacity_curve[2,0]
            
            sa1=capacity_curve[1,1]*9.81
            sd1=capacity_curve[1,0]
            

      else:
            say=capacity_curve[1,1]*9.81
            sdy=capacity_curve[1,0]
            
            sa1=capacity_curve[1,1]*9.81
            sd1=capacity_curve[1,0]
            
      ty=(2*np.pi)/(np.sqrt(say/sdy))
      t1=(2*np.pi)/(np.sqrt(sa1/sd1))
      
      ops.wipe()
      ops.model('basic','-ndm',2,'-ndf',3)
      
      m_star_y=((ty/(2*np.pi))**2)/(sdy/say)
      m_star_1=((t1/(2*np.pi))**2)/(sd1/sa1)      
      mx=m_star_1/(np.sum(phi))
     
      total_mass=0
      # define model geometry
      for i in range(n_storeys+1):
          
          node_tag=int(i)
          
          if i:
              
              ops.node(node_tag,0,0,'-mass',float(mx),1e-6,1e-6)
              vals=[0,1,1]
              ops.fix(int(node_tag), *vals)
              
              total_mass+=mx
              
    
          else: # base note (nodeTag=0)

              ops.node(node_tag,0,0,'-mass',1e-6,1e-6,1e-6)
              vals=[1,1,1]
              ops.fix(int(node_tag), *vals)
             
              
      
      # compute stiffness and displacements
      
      springs_stiffness_matrix,_,_,=springs_parameters(n_storeys,capacity_curve,total_mass,
                                                       gamma,storey_height)
      
      nodal_displacement_matrix=compute_nodal_displacements(springs_stiffness_matrix,
                                                            capacity_curve,total_mass,n_storeys,
                                                            gamma,storey_height)
      
      # create pinching and minmax materials
      
      matTag_pinching=10
      matTag_minmax=100
      
      eleTag=1000
      
      for i in range(n_storeys):
          
          matTag_pinching+=1
          matTag_minmax+=1
          eleTag+=1
          
          f_vec=np.zeros([5,1])
          d_vec=np.zeros([5,1])
          
          
          if len(capacity_curve)==3:
                #bilinear curve
                
                d_vec[1]=nodal_displacement_matrix[1,-1]
                d_vec[4]=nodal_displacement_matrix[-1,-1]
                
                if i==0:
                    
                    f_vec[1]=d_vec[1]*12*springs_stiffness_matrix[1,i]/(storey_height*n_storeys)**3
                    f_vec[4]=d_vec[4]*12*springs_stiffness_matrix[-1,i]/(storey_height*n_storeys)**3

                elif i==n_storeys-1:
                    
                     f_vec[1]=d_vec[1]*x[1]*springs_stiffness_matrix[1,i]/(storey_height*n_storeys)**3
                     f_vec[4]=d_vec[4]*x[1]*springs_stiffness_matrix[-1,i]/(storey_height*n_storeys)**3
                     
                else:
                    
                    f_vec[1]=d_vec[1]*x[0]*springs_stiffness_matrix[1,i]/(storey_height*n_storeys)**3
                    f_vec[4]=d_vec[4]*x[0]*springs_stiffness_matrix[-1,i]/(storey_height*n_storeys)**3
                    

                d_cap=np.array([0,float(d_vec[1]),float(d_vec[4])])
                f_cap=np.array([0,float(f_vec[1]),float(f_vec[4])])
                
                d_vec[2]=d_vec[1]+(d_vec[4]-d_vec[1])/3
                d_vec[3]=d_vec[1]+2*((d_vec[4]-d_vec[1])/3)
                
                f_vec[2]=np.interp(d_vec[2],d_cap,f_cap)
                f_vec[3]=np.interp(d_vec[3],d_cap,f_cap)               
                
                
          elif len(capacity_curve)==4:
                 #trilinear curve
                 
                 d_vec[1]=nodal_displacement_matrix[1,-1]
                 d_vec[4]=nodal_displacement_matrix[-1,-1]
                 
                 d_vec[2]=nodal_displacement_matrix[2,-1]

                 if i==0:
                     
                     f_vec[1]=d_vec[1]*x[0]*springs_stiffness_matrix[1,i]/(storey_height*n_storeys)**3
                     f_vec[4]=d_vec[4]*x[0]*springs_stiffness_matrix[-1,i]/(storey_height*n_storeys)**3
                    
                     f_vec[2]=d_vec[2]*x[0]*springs_stiffness_matrix[2,i]/(storey_height*n_storeys)**3
                     
                 elif i==n_storeys-1:
                     
                      f_vec[1]=d_vec[1]*x[1]*springs_stiffness_matrix[1,i]/(storey_height*n_storeys)**3
                      f_vec[4]=d_vec[4]*x[1]*springs_stiffness_matrix[-1,i]/(storey_height*n_storeys)**3
                     
                      f_vec[2]=d_vec[2]*x[1]*springs_stiffness_matrix[2,i]/(storey_height*n_storeys)**3
                      
                 else:
                     
                     f_vec[1]=d_vec[1]*x[0]*springs_stiffness_matrix[1,i]/(storey_height*n_storeys)**3
                     f_vec[4]=d_vec[4]*x[0]*springs_stiffness_matrix[-1,i]/(storey_height*n_storeys)**3
                    
                     f_vec[2]=d_vec[2]*x[0]*springs_stiffness_matrix[2,i]/(storey_height*n_storeys)**3
                     
                     
    

                 d_cap=np.array([0,float(d_vec[1]),float(d_vec[2]),float(d_vec[4])])
                 f_cap=np.array([0,float(f_vec[1]),float(f_vec[2]),float(f_vec[4])])
                 
                 d_vec[3]=np.mean([d_vec[2],d_vec[-1]])
                 f_vec[3]=np.interp(d_vec[3],d_cap,f_cap)   
                 
                
          elif len(capacity_curve)==5:
                 #quadrilinear curve
                 
                 d_vec[1]=nodal_displacement_matrix[1,-1]
                 d_vec[4]=nodal_displacement_matrix[-1,-1]
                 
                 d_vec[2]=nodal_displacement_matrix[2,-1]
                 d_vec[3]=nodal_displacement_matrix[3,-1]
                 
                 if i==0:
                  
                   f_vec[1]=d_vec[1]*12*springs_stiffness_matrix[1,i]/(storey_height*n_storeys)**3
                   f_vec[4]=d_vec[4]*12*springs_stiffness_matrix[-1,i]/(storey_height*n_storeys)**3
                 
                   f_vec[2]=d_vec[2]*12*springs_stiffness_matrix[2,i]/(storey_height*n_storeys)**3
                   f_vec[3]=d_vec[3]*12*springs_stiffness_matrix[3,i]/(storey_height*n_storeys)**3
                                   
                  
                 elif i==n_storeys-1:
                  
                    f_vec[1]=d_vec[1]*x[1]*springs_stiffness_matrix[1,i]/(storey_height*n_storeys)**3
                    f_vec[4]=d_vec[4]*x[1]*springs_stiffness_matrix[-1,i]/(storey_height*n_storeys)**3
                  
                    f_vec[2]=d_vec[2]*x[1]*springs_stiffness_matrix[2,i]/(storey_height*n_storeys)**3
                    f_vec[3]=d_vec[3]*x[1]*springs_stiffness_matrix[3,i]/(storey_height*n_storeys)**3
                    
                 else:
                     
                     f_vec[1]=d_vec[1]*x[0]*springs_stiffness_matrix[1,i]/(storey_height*n_storeys)**3
                     f_vec[4]=d_vec[4]*x[0]*springs_stiffness_matrix[-1,i]/(storey_height*n_storeys)**3
                   
                     f_vec[2]=d_vec[2]*x[0]*springs_stiffness_matrix[2,i]/(storey_height*n_storeys)**3
                     f_vec[3]=d_vec[3]*x[0]*springs_stiffness_matrix[3,i]/(storey_height*n_storeys)**3
                  
          matargs=[f_vec[1,0],d_vec[1,0],f_vec[2,0],d_vec[2,0],f_vec[3,0],d_vec[3,0],f_vec[4,0],d_vec[4,0],
                                     -1*f_vec[1,0],-1*d_vec[1,0],-1*f_vec[2,0],-1*d_vec[2,0],-1*f_vec[3,0],-1*d_vec[3,0],-1*f_vec[4,0],-1*d_vec[4,0],
                                     0.5,0.25,0.05,
                                     0.5,0.25,0.05,
                                     0,0,0,0,0,
                                     0,0,0,0,0,
                                     0,0,0,0,0,
                                     10,'energy']
            
          ops.uniaxialMaterial('Pinching4', matTag_pinching,*matargs)
          ops.uniaxialMaterial('MinMax', matTag_minmax,matTag_pinching, '-min',-1*d_vec[4,0], '-max', d_vec[4,0])
          
          # create elements          
          nodeTag_i=int(i)
          nodeTag_j=int(i+1)
          
          ops.element('zeroLength',int(eleTag),nodeTag_i,nodeTag_j,"-mat",int(matTag_minmax),"-dir",1)          
      
      return total_mass

def run_test_pushover(n_storeys,capacity_curve,gamma,storey_height,x):
    
    total_mass=build_test_mdof_ops_py(n_storeys,capacity_curve,gamma,storey_height,x)
        
    push_series_tag=200
    push_pattern_load_tag=200

    ops.timeSeries('Linear',push_series_tag)
    ops.pattern('Plain', push_pattern_load_tag,push_series_tag)

    initial_loads_array=compute_storey_force(1,n_storeys,gamma,storey_height)
    load_mult=np.sum(initial_loads_array)

    for i in range(n_storeys+1):
        
        node_tag=int(i)
        loadValues=[initial_loads_array[i],0,0]
        
        ops.load(node_tag, *loadValues)
      
    # Set some parameters
    n_incr=50
    max_disp=np.max(capacity_curve[:,0])*gamma

    disp_incr = max_disp/n_incr# Displacement increment
    current_disp = 0.0
    ok = 0.0

    ops.system('BandGeneral')
    ops.constraints('Transformation')
    ops.numberer('RCM')
    ops.integrator('DisplacementControl',int(n_storeys),1, disp_incr)
    ops.test('NormUnbalance', 1.0e-6, 100)
    ops.algorithm('Newton')
    ops.analysis('Static')

    top_disp=[0]
    load_factor=[0]

    while ok == 0.0 and current_disp < max_disp:

        ok = ops.analyze(1)

        # if the analysis fails try initial tangent iteration
        if ok != 0:
               print("modified newton failed")
               print("regular newton failed .. lets try an initail stiffness for this step")
               ops.test('NormUnbalance', 1.0e-5, 100)
               ops.algorithm('ModifiedNewton', '-initial')
               ok = ops.analyze(1)
               if ok == 0:
                     print("that worked .. back to regular newton")
                     ops.test('NormUnbalance', 1.0e-6, 100)
                     ops.algorithm('Newton')

        current_disp = ops.nodeDisp(int(n_storeys), 1)
        top_disp.append(ops.nodeDisp(int(n_storeys), 1))
        load_factor.append(ops.getLoadFactor(200))
        
    sds=np.array(top_disp)/gamma
    sas=((np.array(load_factor*load_mult)/gamma)/total_mass)/9.81
        
    return top_disp, load_factor*load_mult,sds,sas
    
    
def opt_boundary_conditions(n_storeys,capacity_curve,gamma,storey_height):
    
    def func(x):
        
        _,_,sds,sas=run_test_pushover(n_storeys,capacity_curve,gamma,storey_height,x)
        
        expected_sas=np.interp(sds, capacity_curve[:,0], capacity_curve[:,1])
        
        loss_squared=np.sum((expected_sas-sas)**2)
        
        return loss_squared
    
    solution=optimize.fmin(func,[5.25,5.25],disp=False)
    
    return solution
         

#%%

def build_mdof_ops_py(n_storeys,capacity_curve,gamma,storey_height,x,build_class,degradation=False):
      
      cap_df=pd.DataFrame(capacity_curve)
      if any(cap_df.duplicated()):
            warnings.warn("Warning: Duplicated pairs have been found in capacity curve!")

      phi=compute_modal_shape(gamma,n_storeys)
           
      if capacity_curve.shape[0]>=4:
                  
            say=capacity_curve[2,1]*9.81
            sdy=capacity_curve[2,0]
            
            sa1=capacity_curve[1,1]*9.81
            sd1=capacity_curve[1,0]
            

      else:
            say=capacity_curve[1,1]*9.81
            sdy=capacity_curve[1,0]
            
            sa1=capacity_curve[1,1]*9.81
            sd1=capacity_curve[1,0]
            
      ty=(2*np.pi)/(np.sqrt(say/sdy))
      t1=(2*np.pi)/(np.sqrt(sa1/sd1))
      
      ops.wipe()
      ops.model('basic','-ndm',2,'-ndf',3)
      
      m_star_y=((ty/(2*np.pi))**2)/(sdy/say)
      m_star_1=((t1/(2*np.pi))**2)/(sd1/sa1)      
      mx=m_star_1/(np.sum(phi))
     
      total_mass=0
      # define model geometry
      for i in range(n_storeys+1):
          
          node_tag=int(i)
          
          if i:
              
              ops.node(node_tag,0,0,'-mass',float(mx),1e-6,1e-6)
              vals=[0,1,1]
              ops.fix(int(node_tag), *vals)
              print('NodeTag:'+str(node_tag)+' > created')
              print('NodeTag:'+str(node_tag)+' > coordinates:', [0,0])
              print('NodeTag:'+str(node_tag)+' > mass:'+str(mx))
              total_mass+=mx
              
    
          else: # base note (nodeTag=0)

              ops.node(node_tag,0,0,'-mass',1e-6,1e-6,1e-6)
              vals=[1,1,1]
              ops.fix(int(node_tag), *vals)
              print('NodeTag:'+str(node_tag)+' > created')
              print('NodeTag:'+str(node_tag)+' > coordinates:', [0,float(i*storey_height)])
              print('NodeTag:'+str(node_tag)+' > All DOFs restrained')
              
      print('Total mass: '+str(total_mass))

      # compute stiffness and displacements
      
      springs_stiffness_matrix,_,_,=springs_parameters(n_storeys,capacity_curve,total_mass,
                                                       gamma,storey_height)
      
      nodal_displacement_matrix=compute_nodal_displacements(springs_stiffness_matrix,
                                                            capacity_curve,total_mass,n_storeys,
                                                            gamma,storey_height)
      
      # create pinching and minmax materials
      
      matTag_pinching=10
      matTag_minmax=100
      
      eleTag=1000
      
      fig=plt.figure()
            
      for i in range(n_storeys):
          
          matTag_pinching+=1
          matTag_minmax+=1
          eleTag+=1
          
          f_vec=np.zeros([5,1])
          d_vec=np.zeros([5,1])
          
          if len(capacity_curve)==3:
                #bilinear curve
                
                d_vec[1]=nodal_displacement_matrix[1,-1]
                d_vec[4]=nodal_displacement_matrix[-1,-1]
                
                if i==0:
                    
                    f_vec[1]=d_vec[1]*12*springs_stiffness_matrix[1,i]/(storey_height*n_storeys)**3
                    f_vec[4]=d_vec[4]*12*springs_stiffness_matrix[-1,i]/(storey_height*n_storeys)**3

                elif i==n_storeys-1:
                    
                     f_vec[1]=d_vec[1]*x[1]*springs_stiffness_matrix[1,i]/(storey_height*n_storeys)**3
                     f_vec[4]=d_vec[4]*x[1]*springs_stiffness_matrix[-1,i]/(storey_height*n_storeys)**3
                     
                else:
                    
                    f_vec[1]=d_vec[1]*x[0]*springs_stiffness_matrix[1,i]/(storey_height*n_storeys)**3
                    f_vec[4]=d_vec[4]*x[0]*springs_stiffness_matrix[-1,i]/(storey_height*n_storeys)**3
                    

                d_cap=np.array([0,float(d_vec[1]),float(d_vec[4])])
                f_cap=np.array([0,float(f_vec[1]),float(f_vec[4])])
                
                d_vec[2]=d_vec[1]+(d_vec[4]-d_vec[1])/3
                d_vec[3]=d_vec[1]+2*((d_vec[4]-d_vec[1])/3)
                
                f_vec[2]=np.interp(d_vec[2],d_cap,f_cap)
                f_vec[3]=np.interp(d_vec[3],d_cap,f_cap)               
                
                
          elif len(capacity_curve)==4:
                 #trilinear curve
                 
                 d_vec[1]=nodal_displacement_matrix[1,-1]
                 d_vec[4]=nodal_displacement_matrix[-1,-1]
                 
                 d_vec[2]=nodal_displacement_matrix[2,-1]

                 if i==0:
                     
                     f_vec[1]=d_vec[1]*x[0]*springs_stiffness_matrix[1,i]/(storey_height*n_storeys)**3
                     f_vec[4]=d_vec[4]*x[0]*springs_stiffness_matrix[-1,i]/(storey_height*n_storeys)**3
                    
                     f_vec[2]=d_vec[2]*x[0]*springs_stiffness_matrix[2,i]/(storey_height*n_storeys)**3
                     
                 elif i==n_storeys-1:
                     
                      f_vec[1]=d_vec[1]*x[1]*springs_stiffness_matrix[1,i]/(storey_height*n_storeys)**3
                      f_vec[4]=d_vec[4]*x[1]*springs_stiffness_matrix[-1,i]/(storey_height*n_storeys)**3
                     
                      f_vec[2]=d_vec[2]*x[1]*springs_stiffness_matrix[2,i]/(storey_height*n_storeys)**3
                      
                 else:
                     
                     f_vec[1]=d_vec[1]*x[0]*springs_stiffness_matrix[1,i]/(storey_height*n_storeys)**3
                     f_vec[4]=d_vec[4]*x[0]*springs_stiffness_matrix[-1,i]/(storey_height*n_storeys)**3
                    
                     f_vec[2]=d_vec[2]*x[0]*springs_stiffness_matrix[2,i]/(storey_height*n_storeys)**3
                     
                     
    

                 d_cap=np.array([0,float(d_vec[1]),float(d_vec[2]),float(d_vec[4])])
                 f_cap=np.array([0,float(f_vec[1]),float(f_vec[2]),float(f_vec[4])])
                 
                 d_vec[3]=np.mean([d_vec[2],d_vec[-1]])
                 f_vec[3]=np.interp(d_vec[3],d_cap,f_cap)   
                 
                
          elif len(capacity_curve)==5:
                 #quadrilinear curve
                 
                 d_vec[1]=nodal_displacement_matrix[1,-1]
                 d_vec[4]=nodal_displacement_matrix[-1,-1]
                 
                 d_vec[2]=nodal_displacement_matrix[2,-1]
                 d_vec[3]=nodal_displacement_matrix[3,-1]
                 
                 if i==0:
                  
                   f_vec[1]=d_vec[1]*12*springs_stiffness_matrix[1,i]/(storey_height*n_storeys)**3
                   f_vec[4]=d_vec[4]*12*springs_stiffness_matrix[-1,i]/(storey_height*n_storeys)**3
                 
                   f_vec[2]=d_vec[2]*12*springs_stiffness_matrix[2,i]/(storey_height*n_storeys)**3
                   f_vec[3]=d_vec[3]*12*springs_stiffness_matrix[3,i]/(storey_height*n_storeys)**3
                                   
                  
                 elif i==n_storeys-1:
                  
                    f_vec[1]=d_vec[1]*x[1]*springs_stiffness_matrix[1,i]/(storey_height*n_storeys)**3
                    f_vec[4]=d_vec[4]*x[1]*springs_stiffness_matrix[-1,i]/(storey_height*n_storeys)**3
                  
                    f_vec[2]=d_vec[2]*x[1]*springs_stiffness_matrix[2,i]/(storey_height*n_storeys)**3
                    f_vec[3]=d_vec[3]*x[1]*springs_stiffness_matrix[3,i]/(storey_height*n_storeys)**3
                    
                 else:
                     
                     f_vec[1]=d_vec[1]*x[0]*springs_stiffness_matrix[1,i]/(storey_height*n_storeys)**3
                     f_vec[4]=d_vec[4]*x[0]*springs_stiffness_matrix[-1,i]/(storey_height*n_storeys)**3
                   
                     f_vec[2]=d_vec[2]*x[0]*springs_stiffness_matrix[2,i]/(storey_height*n_storeys)**3
                     f_vec[3]=d_vec[3]*x[0]*springs_stiffness_matrix[3,i]/(storey_height*n_storeys)**3
                     
          plt.plot(d_vec,f_vec,label=str(i))
          plt.legend()
          plt.xlabel('Top displacement [m]')
          plt.ylabel('Base Shear [KN]')
          plt.savefig(os.path.join(os.getcwd(),'springs_'+build_class+'.png'))
                    
          
          if degradation==True:
                matargs=[f_vec[1,0],d_vec[1,0],f_vec[2,0],d_vec[2,0],f_vec[3,0],d_vec[3,0],f_vec[4,0],-1*d_vec[4,0],
                                     -1*f_vec[1,0],-1*d_vec[1,0],-1*f_vec[2,0],-1*d_vec[2,0],-1*f_vec[3,0],-1*d_vec[3,0],-1*f_vec[4,0],-1*d_vec[4,0],
                                     0.5,0.25,0.05,
                                     0.5,0.25,0.05,
                                     0,0.1,0,0,0.2,
                                     0,0.1,0,0,0.2,
                                     0,0.4,0,0.4,0.9,
                                     10,'energy']
                
          else:
                matargs=[f_vec[1,0],d_vec[1,0],f_vec[2,0],d_vec[2,0],f_vec[3,0],d_vec[3,0],f_vec[4,0],d_vec[4,0],
                                     -1*f_vec[1,0],-1*d_vec[1,0],-1*f_vec[2,0],-1*d_vec[2,0],-1*f_vec[3,0],-1*d_vec[3,0],-1*f_vec[4,0],-1*d_vec[4,0],
                                     0.5,0.25,0.05,
                                     0.5,0.25,0.05,
                                     0,0,0,0,0,
                                     0,0,0,0,0,
                                     0,0,0,0,0,
                                     10,'energy']
            
          ops.uniaxialMaterial('Pinching4', matTag_pinching,*matargs)
          ops.uniaxialMaterial('MinMax', matTag_minmax,matTag_pinching, '-min',-1*d_vec[4,0], '-max', d_vec[4,0])
          
          # create elements          
          nodeTag_i=int(i)
          nodeTag_j=int(i+1)
          
          ops.element('zeroLength',int(eleTag),nodeTag_i,nodeTag_j,"-mat",int(matTag_minmax),"-dir",1)          
          print('zeroLengthTag:'+str(eleTag)+' NodeI:'+str(nodeTag_i)+' NodeJ:'+str(nodeTag_j)+' > created')
          print('zeroLengthTag:'+str(eleTag)+' Pinching4#:'+str(matTag_pinching)+' MinMax#:'+str(matTag_minmax))
          
          #print('Pinching4 properties: ',matargs)
      
      return total_mass

#%%
def effective_duration(gmr):
      
      npts=gmr.shape[0]
      
      sq_accels=np.square(gmr[:,1])
      
      dt=gmr[1,0]-gmr[0,0]
      
      arias=np.zeros([npts-1,1])
      
      sum_var=0
      
      for i in range(npts-1):
            
            sum_var=sum_var+(np.pi/(2*9.81)*(sq_accels[i+1]+sq_accels[i])/(2*dt))
            arias[i,0]=sum_var
            
      index1=np.argmax(arias>=0.05*sum_var)
      index2=np.argmax(arias>0.95*sum_var)
      
      eff_accel=gmr[index1:index2,1].reshape([index2-index1,1])
      eff_time=np.linspace(0,(index2-index1)*dt,(index2-index1)).reshape([index2-index1,1])
      
      eff_gmr=np.hstack([eff_time,eff_accel])
      
      
      return eff_gmr,dt,index1,index2

#%%
def run_nlth_analysis_on_mdof_ops_py(results_folder,n_storeys,capacity_curve,gamma,storey_height,gmr,damping,degradation=False):
    
    # build model
    build_mdof_ops_py(n_storeys,capacity_curve,gamma,storey_height,degradation)
    
    gmr_values=gmr[:,1]*9.81
    gmr_times=gmr[:,0]
    
    dt=gmr[1,0]-gmr[0,0]
    
    ops.timeSeries('Path', 2,'-values',*gmr_values,'-time',*gmr_times)
    ops.pattern('UniformExcitation',2,1,'-accel',2)
    
    ops.constraints('Plain')
    ops.numberer('RCM')
    ops.test('NormDispIncr',1e-6,50)
    ops.algorithm('Newton')
    ops.system('BandGeneral')
    ops.integrator('Newmark',0.5,0.25)
    ops.analysis('Transient')
    
    eigenValues = ops.eigen(1)
    omega=np.sqrt(eigenValues[0])
    
    t_final=gmr[-1,0]
    t_current=ops.getTime()

    ok=0
    betaKinit=2*damping/omega
    time=[t_current]

    ops.rayleigh(0,0,betaKinit,0)
    
    disp_file=os.path.join(results_folder,'nodal_disps.txt')
    accel_file=os.path.join(results_folder,'nodal_accels.txt')
    
    ops.recorder('Node', '-file', disp_file, '-time', '-nodeRange', 0, int(n_storeys), '-dof', *[1], 'disp')
    ops.recorder('Node', '-file', accel_file, '-time', '-nodeRange', 0, int(n_storeys), '-dof', *[1], 'accel')
    
    while ok == 0 and t_current < t_final:
          ok=ops.analyze(1,dt)
          if ok !=0:
                print("regular newton failed ... lets try an initail stiffness for this step")
                ops.test('NormDispIncr',1.0e-6,100,0)
                ops.algorithm('ModifiedNewton', '-initial')
                ok=ops.analyze(1,dt)
                if ok!=0:
                      print("reducing dt by 10")
                      ndt=dt/10
                      ok=ops.analyze(10,ndt)
                if ok==0:
                      print("that worked ... back to regular settings")
                      ops.test('NormDispIncr',1e-6,50)
                      ops.test('NormDispIncr',1e-6,50)
          t_current = ops.getTime()
          time.append(t_current)

    return True     
