# -*- coding: utf-8 -*-
"""
Created on Fri Jan 17 08:55:51 2020

@author: LuisMartins
"""


import openseespy.opensees as ops
import numpy as np
import pandas as pd
import warnings
import os
from scipy import optimize
import matplotlib.pyplot as plt
#%%

def compute_modal_shape(gamma,n_storeys,storey_height=2.8):
    
    phi=np.zeros(n_storeys)
    total_height=n_storeys*storey_height
    
    storey_heights=[(i+1)*storey_height for i in range(n_storeys)]
        
    def func(x):
        
        for i in range(n_storeys):
            
            if i==(n_storeys-1):
                phi[i]=1.0
            else:
                phi[i]=x[i]
      
        computed_gamma=np.sum(phi)/np.sum(phi**2)        
        loss_squared=(gamma-computed_gamma)**2
        
        return loss_squared
           
    solution=optimize.fmin(func,[storey_heights[i]/total_height for i in range(n_storeys-1)],disp=False)
    
    for i in range(n_storeys):
        
        if i==(n_storeys-1):
            phi[i]=1.0
        else:
            phi[i]=solution[i]
    
    return phi
#%%

def compute_storey_force(total_base_shear,n_storeys,gamma,storey_height):
    
    # this function computes the lateral force at floor level assuming a distribution proportional to phi1
    # it outputs an array where node0=force at base (it is 0 always) and noden= force at top
    
    phi=compute_modal_shape(gamma,n_storeys,storey_height)
    
    ratios=np.concatenate([np.array([0]),phi])
    
    force_at_top_floor=total_base_shear/np.sum(ratios)
    
    nodal_lateral_forces=force_at_top_floor*ratios   
    
    return nodal_lateral_forces
#%%
   
def compute_M_at_floors(nodal_lateral_forces,n_storeys,storey_height):
    
    storey_heights=storey_height*np.linspace(start=0,
                                             stop=n_storeys,
                                             num=n_storeys+1,endpoint=True)
    
    nodal_moment_value=np.zeros(storey_heights.shape)
    
    for i in reversed(range(n_storeys)):
        
        nodal_moment_value[i]=np.sum(np.multiply(nodal_lateral_forces[i+1:],
                                                  storey_heights[i+1:]-storey_heights[i]))
    return nodal_moment_value
#%%

def compute_M_M_integral(L,M1,M2,M3,M4):
    
    # this computes the M-M' integral assuming a trapesoidal distribution
    
    # M1 M2 are the moments for M
    # M3 M4 are the moments for M'    
    
    return L/6*(M1*(2*M3+M4)+M2*(M3+2*M4))
#%%
   
def springs_parameters(n_storeys,capacity_curve_array,gamma,storey_height=2.8):
      
    roof_displacement_array=capacity_curve_array[:,0]*gamma
    base_shear_array=capacity_curve_array[:,1]*9.81*gamma
    
    # estimate different periods (i.e. T1, Ty, ...,Tult)
    periods_array=np.zeros(capacity_curve_array.shape[0]-1)
    
    for i in range(1,capacity_curve_array.shape[0]):
        
        periods_array[i-1]=np.sqrt((2*np.pi)**2/\
                        ((capacity_curve_array[i,1]*9.81)/capacity_curve_array[i,0]))
                 
    # multiplication factor to account for linear reduction of stiffness with height
    # K_storey=mult*K_constant

    b=((1-n_storeys**2)/(-1*n_storeys+1))
    m=(n_storeys-((1-n_storeys**2)/(-1*n_storeys+1)))
    
    stiff_storey_mult=[m*(i+1)+b for i in range(n_storeys)]
        
    # using the force method lets compute the EI value that leads to the roof displacement and base shear 
    # in the capacity curve (the lateral loads are assumed to be a triangular shape)
    # d_roof=1/EI*integral(M*M'dx)
    
    storey_heights=storey_height*np.linspace(start=0,
                                             stop=n_storeys,
                                             num=n_storeys+1,endpoint=True)
    
    springs_stiffness_matrix=np.zeros([capacity_curve_array.shape[0],n_storeys])
    
    for i in range(1,capacity_curve_array.shape[0]):
        
        lateral_loads=compute_storey_force(base_shear_array[i],n_storeys,gamma,storey_height)
        
        m_values=compute_M_at_floors(lateral_loads,n_storeys,storey_height)
        
        m_aux_values=compute_M_at_floors(np.array([0 if _<n_storeys else 1 for _ in range(n_storeys+1)]),
                                         n_storeys,storey_height)
        
        sum_accumulator=0
        
        for j in range(n_storeys):
            
            M1=m_values[j]
            M2=m_values[j+1]
            
            M3=m_aux_values[j]
            M4=m_aux_values[j+1]
            
            L=storey_heights[j+1]-storey_heights[j]
            
            integral=compute_M_M_integral(L,M1,M2,M3,M4)
            
            sum_accumulator+=(1/stiff_storey_mult[j])*integral
        
        EI=1/roof_displacement_array[i]*sum_accumulator
        
        springs_stiffness_matrix[i,:]=np.array(stiff_storey_mult)*EI
    
    return springs_stiffness_matrix,stiff_storey_mult,periods_array
#%%

def compute_nodal_displacements(springs_stiffness_matrix,capacity_curve_array,n_storeys,gamma,storey_height):
    
    nodal_displacement_matrix=np.zeros([capacity_curve_array.shape[0],n_storeys+1])
    
    storey_heights=storey_height*np.linspace(start=0,
                                             stop=n_storeys,
                                             num=n_storeys+1,endpoint=True)
    
    base_shear_array=capacity_curve_array[:,1]*9.81*gamma
    
    for i in range(1,capacity_curve_array.shape[0]):
        
        lateral_loads=compute_storey_force(base_shear_array[i],n_storeys,gamma,storey_height)
        
        m_values=compute_M_at_floors(lateral_loads,n_storeys,storey_height)
        
        for j in range(n_storeys+1):
            
            m_aux_values=compute_M_at_floors(np.array([1 if _==j else 0 for _ in range(n_storeys+1)]),
                                             n_storeys,storey_height)
            
            sum_accumulator=0
            
            for k in range(n_storeys):
                
                M1=m_values[k]
                M2=m_values[k+1]
                
                M3=m_aux_values[k]
                M4=m_aux_values[k+1]
                
                L=storey_heights[k+1]-storey_heights[k]
                
                integral=compute_M_M_integral(L,M1,M2,M3,M4)
                
                EIk=springs_stiffness_matrix[i,k]
                
                sum_accumulator+=(1/EIk)*integral
                
            nodal_displacement_matrix[i,j]=sum_accumulator
            
    return nodal_displacement_matrix 
#%%

def build_mdof_ops_py(n_storeys,capacity_curve,gamma,storey_height,degradation=False):
      
      cap_df=pd.DataFrame(capacity_curve)
      if any(cap_df.duplicated()):
            warnings.warn("Warning: Duplicated pairs have been found in capacity curve!")
            
      
      springs_stiffness_matrix,_,_,=springs_parameters(n_storeys,capacity_curve,
                                                       gamma,storey_height)
      
      nodal_displacement_matrix=compute_nodal_displacements(springs_stiffness_matrix,
                                                            capacity_curve,n_storeys,
                                                            gamma,storey_height)
      
      phi=compute_modal_shape(gamma,n_storeys)
      
      max_displ=capacity_curve[-1,0]*gamma
      
      if capacity_curve.shape[0]>=4:
                  
            sa=capacity_curve[2,1]*9.81
            sd=capacity_curve[2,0]

      else:
            sa=capacity_curve[1,1]*9.81
            sd=capacity_curve[1,0]
            
      ty=(2*np.pi)/(np.sqrt(sa/sd))
      
      ops.wipe()
      ops.model('basic','-ndm',2,'-ndf',3)
      
      m_star=((ty/(2*np.pi))**2)/(sd/sa)      
      mx=m_star/(np.sum(phi))
      
      # define model geometry
      for i in range(n_storeys+1):
          
          node_tag=int(i)
          if i:
              
              ops.node(node_tag,0,0,'-mass',float(mx),1e-6,1e-6)
              vals=[0,1,1]
              ops.fix(int(node_tag), *vals)
          else: # base note (nodeTag=0)

              ops.node(node_tag,0,0,'-mass',1e-6,1e-6,1e-6)
              vals=[1,1,1]
              ops.fix(int(node_tag), *vals)
              
      # create pinching and minmax materials
      
      matTag_pinching=10
      matTag_minmax=100
      
      eleTag=1000
      
      fig=plt.figure()
      
      for i in range(n_storeys):
          
          matTag_pinching+=1
          matTag_minmax+=1
          eleTag+=1
          
          f_vec=np.zeros([5,1])
          d_vec=np.zeros([5,1])
          
          node_rel_displ=(nodal_displacement_matrix[:,i+1]-nodal_displacement_matrix[:,i])
          
          if len(capacity_curve)==3:
                #bilinear curve
                
                denominator=(storey_height**3)/3
                
                d_vec[1]=node_rel_displ[1]
                d_vec[4]=node_rel_displ[-1]
                
                f_vec[1]=d_vec[1]*springs_stiffness_matrix[1,i]/denominator
                f_vec[4]=d_vec[4]*springs_stiffness_matrix[-1,i]/denominator
                
                d_cap=np.array([0,d_vec[1],d_vec[4]])
                f_cap=np.array([0,f_vec[1],f_vec[4]])
                
                d_vec[2]=d_vec[1]+(d_vec[4]-d_vec[1])/3
                d_vec[3]=d_vec[1]+2*((d_vec[4]-d_vec[1])/3)
                
                f_vec[2]=np.interp(d_vec[2],d_cap,f_cap)
                f_vec[3]=np.interp(d_vec[3],d_cap,f_cap)               
                
                
          elif len(capacity_curve)==4:
                 #trilinear curve
                 
                 denominator=(storey_height**3)/3
                 
                 d_vec[1]=node_rel_displ[1]
                 d_vec[4]=node_rel_displ[-1]
                 
                 f_vec[1]=d_vec[1]*springs_stiffness_matrix[1,i]/denominator
                 f_vec[4]=d_vec[4]*springs_stiffness_matrix[-1,i]/denominator
                 
                 d_vec[2]=node_rel_displ[2]
                 f_vec[2]=d_vec[2]*springs_stiffness_matrix[2,i]/denominator
                 
                 d_cap=np.array([0,d_vec[1],d_vec[2],d_vec[4]])
                 f_cap=np.array([0,f_vec[1],f_vec[2],f_vec[4]])/denominator
                 
                 d_vec[3]=np.mean([d_vec[2],d_vec[-1]])
                 f_vec[3]=np.interp(d_vec[3],d_cap,f_cap)   
                 
                
          elif len(capacity_curve)==5:
                 #quadrilinear curve
                 
                 denominator=(storey_height**3)/3
                 
                 d_vec[1]=node_rel_displ[1]
                 d_vec[4]=node_rel_displ[-1]
                 
                 f_vec[1]=d_vec[1]*springs_stiffness_matrix[1,i]/denominator
                 f_vec[4]=d_vec[4]*springs_stiffness_matrix[-1,i]/denominator
                 
                 d_vec[2]=node_rel_displ[2]
                 d_vec[3]=node_rel_displ[3]
                 
                 f_vec[2]=d_vec[2]*springs_stiffness_matrix[2,i]/denominator
                 f_vec[3]=d_vec[3]*springs_stiffness_matrix[3,i]/denominator
                 
          plt.plot(d_vec,f_vec,label=str(i))
          plt.legend()
          plt.savefig(os.path.join(os.getcwd(),'springs.png'))
                           
          if degradation==True:
                matargs=[f_vec[1,0],d_vec[1,0],f_vec[2,0],d_vec[2,0],f_vec[3,0],d_vec[3,0],f_vec[4,0],-1*d_vec[4,0],
                                     -1*f_vec[1,0],-1*d_vec[1,0],-1*f_vec[2,0],-1*d_vec[2,0],-1*f_vec[3,0],-1*d_vec[3,0],-1*f_vec[4,0],-1*d_vec[4,0],
                                     0.5,0.25,0.05,
                                     0.5,0.25,0.05,
                                     0,0.1,0,0,0.2,
                                     0,0.1,0,0,0.2,
                                     0,0.4,0,0.4,0.9,
                                     10,'energy']
                
          else:
                matargs=[f_vec[1,0],d_vec[1,0],f_vec[2,0],d_vec[2,0],f_vec[3,0],d_vec[3,0],f_vec[4,0],d_vec[4,0],
                                     -1*f_vec[1,0],-1*d_vec[1,0],-1*f_vec[2,0],-1*d_vec[2,0],-1*f_vec[3,0],-1*d_vec[3,0],-1*f_vec[4,0],-1*d_vec[4,0],
                                     0.5,0.25,0.05,
                                     0.5,0.25,0.05,
                                     0,0,0,0,0,
                                     0,0,0,0,0,
                                     0,0,0,0,0,
                                     10,'energy']
          
          ops.uniaxialMaterial('Pinching4', matTag_pinching,*matargs)
          ops.uniaxialMaterial('MinMax', matTag_minmax,matTag_pinching, '-min',-1*d_vec[4,0], '-max', d_vec[4,0])
          
          # create elements
          
          nodeTag_i=int(i)
          nodeTag_j=int(i+1)
          
          ops.element('zeroLength',int(eleTag),nodeTag_i,nodeTag_j,"-mat",int(matTag_minmax),"-dir",1)
      
      return True

#%%
def effective_duration(gmr):
      
      npts=gmr.shape[0]
      
      sq_accels=np.square(gmr[:,1])
      
      dt=gmr[1,0]-gmr[0,0]
      
      arias=np.zeros([npts-1,1])
      
      sum_var=0
      
      for i in range(npts-1):
            
            sum_var=sum_var+(np.pi/(2*9.81)*(sq_accels[i+1]+sq_accels[i])/(2*dt))
            arias[i,0]=sum_var
            
      index1=np.argmax(arias>=0.05*sum_var)
      index2=np.argmax(arias>0.95*sum_var)
      
      eff_accel=gmr[index1:index2,1].reshape([index2-index1,1])
      eff_time=np.linspace(0,(index2-index1)*dt,(index2-index1)).reshape([index2-index1,1])
      
      eff_gmr=np.hstack([eff_time,eff_accel])
      
      
      return eff_gmr,dt,index1,index2

#%%
def run_nlth_analysis_on_mdof_ops_py(results_folder,n_storeys,capacity_curve,gamma,storey_height,gmr,damping,degradation=False):
    
    # build model
    build_mdof_ops_py(n_storeys,capacity_curve,gamma,storey_height,degradation)
    
    gmr_values=gmr[:,1]*9.81
    gmr_times=gmr[:,0]
    
    dt=gmr[1,0]-gmr[0,0]
    
    ops.timeSeries('Path', 2,'-values',*gmr_values,'-time',*gmr_times)
    ops.pattern('UniformExcitation',2,1,'-accel',2)
    
    ops.constraints('Plain')
    ops.numberer('RCM')
    ops.test('NormDispIncr',1e-6,50)
    ops.algorithm('Newton')
    ops.system('BandGeneral')
    ops.integrator('Newmark',0.5,0.25)
    ops.analysis('Transient')
    
    eigenValues = ops.eigen(1)
    omega=np.sqrt(eigenValues[0])
    
    t_final=gmr[-1,0]
    t_current=ops.getTime()

    ok=0
    betaKinit=2*damping/omega
    time=[t_current]

    ops.rayleigh(0,0,betaKinit,0)
    
    disp_file=os.path.join(results_folder,'nodal_disps.txt')
    accel_file=os.path.join(results_folder,'nodal_accels.txt')
    
    ops.recorder('Node', '-file', disp_file, '-time', '-nodeRange', 0, int(n_storeys), '-dof', *[1], 'disp')
    ops.recorder('Node', '-file', accel_file, '-time', '-nodeRange', 0, int(n_storeys), '-dof', *[1], 'accel')
    
    while ok == 0 and t_current < t_final:
          ok=ops.analyze(1,dt)
          if ok !=0:
                print("regular newton failed ... lets try an initail stiffness for this step")
                ops.test('NormDispIncr',1.0e-6,100,0)
                ops.algorithm('ModifiedNewton', '-initial')
                ok=ops.analyze(1,dt)
                if ok!=0:
                      print("reducing dt by 10")
                      ndt=dt/10
                      ok=ops.analyze(10,ndt)
                if ok==0:
                      print("that worked ... back to regular settings")
                      ops.test('NormDispIncr',1e-6,50)
                      ops.test('NormDispIncr',1e-6,50)
          t_current = ops.getTime()
          time.append(t_current)

    return True     
