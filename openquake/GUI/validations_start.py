# -*- coding: utf-8 -*-
"""
Created on Mon Jul 20 09:46:52 2020

@author: LuisMartins
"""

import numpy as np 
import statsmodels.api as sm

# %% 

def efficiency(sds,imls,censored_lim):
      
      bool_vec=(sds>censored_lim)
      sds=np.delete(np.array(sds),np.argwhere(bool_vec))
      imls=np.delete(np.array(imls),np.argwhere(bool_vec))
      
      ln_sd=np.reshape(np.log(sds),(len(np.log(sds)),1))
      ln_IM=np.reshape(np.log(imls),(len(np.log(imls)),1))
      
      y1=ln_sd
      X1=np.concatenate((np.ones([len(y1),1]),ln_IM),axis=1)
      
      b1=np.linalg.lstsq(X1,y1,rcond=None)
      b1_closed_form=np.dot(np.dot(np.linalg.pinv(np.dot(X1.T,X1)),X1.T),y1)
      epsilon=np.linalg.norm(b1[0]-b1_closed_form)/(np.linalg.norm(b1[0])+np.linalg.norm(b1_closed_form))
      
      if epsilon>1e-7:
            print('Warning: Linear regression produced estimates far from closed form!')
      
      im_vals=np.linspace(np.min(imls),np.max(imls))
      ln_sd_regr=b1[0][0]+b1[0][1]*np.log(im_vals)
      ln_sd_regr=np.reshape(ln_sd_regr,(ln_sd_regr.shape[0],1))
      
      n=sds.shape[0]
      ln_med=b1[0][0]+b1[0][1]*np.log(imls)
      ln_med=np.reshape(ln_med,(ln_med.shape[0],1))
      dispers_1=np.sqrt(np.sum((ln_sd-ln_med)**2)/(n-2))
      
      return dispers_1, epsilon


# %%

def sufficiency(sds,imls,censored_lim,Mw,R):
      
      bool_vec=(sds>censored_lim)
      
      sds=np.delete(np.array(sds),np.argwhere(bool_vec))
      imls=np.delete(np.array(imls),np.argwhere(bool_vec))
      Mw=np.delete(np.array(Mw),np.argwhere(bool_vec))
      R=np.delete(np.array(R),np.argwhere(bool_vec))
      
      ln_sd=np.reshape(np.log(sds),(len(np.log(sds)),1))
      ln_IM=np.reshape(np.log(imls),(len(np.log(imls)),1))
      
      y1=ln_sd
      X1=np.concatenate((ln_IM,Mw),axis=1)
      
      mod = sm.OLS(y1,X1)
      fii = mod.fit()
      p_values_on_M = fii.summary2().tables[1]['P>|t|']
      
      if p_values_on_M[1]>0.05:
            suff_on_M=True
      else:
            suff_on_M=False
      
      y2=ln_sd
      X2=np.concatenate((ln_IM,R),axis=1)
      
      mod = sm.OLS(y2,X2)
      fii = mod.fit()
      p_values_on_R = fii.summary2().tables[1]['P>|t|']
      
      if p_values_on_R[1]>0.05:
            suff_on_R=True
      else:
            suff_on_R=False
      
      return suff_on_M, suff_on_R

# %%

def aal_calc(frag_vul_array,hzd_array,rtP=1):
      
    # Inputs
    # hzd_array - 2D array with the hazard curve [IMLs PoE]
    # frag_vul_array - 2D array containing either the vul curve or the collapse
    # fragilty curve depending if AAL or AAPC is needed
    # rtP - return period of the hazard curve (default 1)

    # Outputs
    # aal_aapc - average annual loss or average annual probability of collapse
    # depening is vul curve or fragility curve is given 
      
    
      mean_imls=(hzd_array[0:-1,0]+hzd_array[1:,0])/2
      rate_occ=(hzd_array[0:-1,1]/rtP)-(hzd_array[1:,1]/rtP)
      
      curve_imls=np.concatenate(([0],frag_vul_array[:,0],[10]))
      curve_ordinates=np.concatenate(([0],frag_vul_array[:,-1],[1]))
      
      aal_aapc=np.sum(np.multiply(np.interp(mean_imls,curve_imls,curve_ordinates),rate_occ))
      
      
      return aal_aapc

# %%

def read_gem_functions(filename):
      
      indata=np.genfromtxt(filename,delimiter=',',dtype=str)
      
      in_num_data=indata[1:,:].astype(dtype='float')
      
      in_str_data=np.reshape(indata[:,0].astype(dtype='str'),(len(indata[:,0]),1))
      
      IM=in_str_data[0,0].replace('[g]','')
      
      return IM, in_num_data
