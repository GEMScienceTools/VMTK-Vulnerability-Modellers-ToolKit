# -*- coding: utf-8 -*-
"""
Created on Wed Oct 16 09:20:34 2019

@author: LuisMartins
"""

import numpy as np
import math 
import os
# %%
class Capacity:
      
      # The capacity object is defined by its type (roofDisp vs baseShear
      # or spectralDisp vs spectralAccel)
      # This will always yield the sds vs sas for the structure
      
      def __init__(self,type_of_curve):
            self.type_of_curve=None
            
      @property
      def type_of_curve(self):
            return self.type_of_curve

# %%
def read_capacity_curves(filename):
      
      # This function reads a csv file containing the sds and sas to an array.
      # If multiple capacity curves are to be read the sds and sas
      # values should be attached next to each other
      
      # __example of an input file with multiple capacity curves__
      
      # Sd1,Sa1,Sd2,Sa2,...,Sdn,San
      # 0.01,0.1,0.015,0.09,...,0.009,0.089
      # 0.015,0.12,0.016,0.01,...,0.01,0.09

      capacity_input=np.loadtxt(filename,dtype=float,delimiter=',') # read csv
      
      bool_test=capacity_input[0]==0
      
      if bool_test.all():
            capacity_array=capacity_input
      else:
            # adds a row at the beggining to start the cap curve at the origin
            capacity_array=np.append(np.zeros([1,np.size(capacity_input,1)]),capacity_input,axis=0)

      return capacity_array

# %%
def get_notable_capacity_pts(capacity_array):
      
      no_capacity_curves=np.size(capacity_array,1)/2
      no_capacity_lines=np.size(capacity_array)
      
      sdys=np.zeros(no_capacity_curves) #stores yield displacements
      sdus=np.zeros(no_capacity_curves) #stores ult displacements
      
      says=np.zeros(no_capacity_curves) #stores yield accels
      saus=np.zeros(no_capacity_curves) #stores ult accels
      
      for i in range(no_capacity_curves):
            x_array=capacity_array[:,2*i]
            y_array=capacity_array[:,2*i+1]
            
            if no_capacity_lines>5:
                  x_array_fit,y_array_fit=polylinear_curve_fit(x_array,y_array)
                  
                  sdys[i]=x_array_fit[2]
                  sdus[i]=x_array_fit[-1]
                  
                  says[i]=y_array_fit[2]
                  saus[i]=y_array_fit[-1]
            else:
                  sdys[i]=x_array[2]
                  sdus[i]=x_array[-1]
                  
                  says[i]=y_array[2]
                  saus[i]=y_array[-1]
      
      return sdys,sdus,says,saus

# %%
def polylinear_curve_fit(x_array,y_array,n_segments=4):
      
      # This functon takes a generic curve and fits n linear segments through 
      # adaptive interpolation
      
      n_pts=n_segments+1; # number of points of the fitted curve
      
      indices=np.round(np.linspace(0,np.size(y_array)-1,n_pts,endpoint=True,dtype=int),decimals=0)
      derivative_approx = np.diff(y_array[indices])
      inv_diff=1/np.abs(derivative_approx)
      weight_of_section=inv_diff/np.sum(inv_diff)
      
      total_range=np.max(x_array)-np.min(x_array)
      size_of_section=weight_of_section*total_range
      
      # fitted curve points
      x_array_fit=x_array[0]*np.append([0],np.cumsum(size_of_section))
      y_array_fit=np.interp(x_array_fit,x_array,y_array)
      
      return x_array_fit,y_array_fit

# %%

