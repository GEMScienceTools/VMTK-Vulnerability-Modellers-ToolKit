# -*- coding: utf-8 -*-
"""
Created on Thu Dec  5 15:02:10 2019

@author: LuisMartins
"""
import numpy as np
import math 
import os

#%%
class Capacity:
      
      # The capacity object is defined by its tag, spectral displacements and 
      # spectral acceleration values

      # tag - string that connects the building class to the capacity 
      # spectral_displ - x values on the capacity object
      # spectral_accel - y values on the capacity object
      
      def __init__(self,tag,spectral_displ,spectral_accel):
            self.tag=None
            self.spectral_displ=None
            self.spectral_accel=None
            
      @property
      def tag(self):
            return self.tag
      
      @property
      def spectral_displ(self):
            return self.spectral_displ
      
      @property
      def spectral_accel(self):
            return self.spectral_accel
      

#%%
def read_capacity_csv_file(filename):
      
      # This function reads a csv file containing the sds and sas to an array.
      # If multiple capacity curves are to be read the sds and sas
      # values should be attached next to each other
      
      # __example of an input file with multiple capacity curves__
      
      # Sd1,Sa1,Sd2,Sa2,...,Sdn,San
      # 0.01,0.1,0.015,0.09,...,0.009,0.089
      # 0.015,0.12,0.016,0.01,...,0.01,0.09
      
      capacity_input=np.loadtxt(filename,dtype=float,delimiter=',') # read csv
      
      bool_test=capacity_input[0]==0
      
      if bool_test.all():
            capacity_array=capacity_input
      else:
            # adds a row at the beggining to start the cap curve at the origin
            capacity_array=np.append(np.zeros([1,np.size(capacity_input,1)]),capacity_input,axis=0)
      
      x_vals=capacity_array[:,::2]; y_vals=capacity_array[:,1::2]
      
      return capacity_array,x_vals,y_vals

# %%
def get_notable_capacity_pts(capacity_array):
      
      no_capacity_curves=np.array(np.size(capacity_array,1)/2,dtype=int)
      no_capacity_lines=np.array(np.size(capacity_array,0))
      
      sdys=np.zeros(no_capacity_curves) #stores yield displacements
      sdus=np.zeros(no_capacity_curves) #stores ult displacements
      
      says=np.zeros(no_capacity_curves) #stores yield accels
      saus=np.zeros(no_capacity_curves) #stores ult accels
      
      for i in range(no_capacity_curves):
            x_array=capacity_array[:,2*i]
            y_array=capacity_array[:,2*i+1]
            
            if no_capacity_lines>5:
                  
                  # this case should happen when a cap curve generated through a 
                  # numerical model is used
                  
                  x_array_fit,y_array_fit=polylinear_curve_fit(x_array,y_array)
                  
                  # using a real capacity curve from a numerical model I tested
                  # and for 10pts polylinearfit the point at -4 position looks
                  # a good approx of the yield point
                  
                  sdys[i]=x_array_fit[-4]
                  sdus[i]=x_array_fit[-1]
                  
                  says[i]=y_array_fit[-4]
                  saus[i]=y_array_fit[-1]
                  
            elif no_capacity_lines>3:
                  
                  # case of a trilinear/quadrilinear model
                  
                  sdys[i]=x_array[2]
                  sdus[i]=x_array[-1]
                  
                  says[i]=y_array[2]
                  saus[i]=y_array[-1]
                  
            else:
                  # case of a bilinear model
                  
                  sdys[i]=x_array[1]
                  sdus[i]=x_array[-1]
                  
                  says[i]=y_array[1]
                  saus[i]=y_array[-1]
      
      return sdys,sdus,says,saus

# %%
def polylinear_curve_fit(x_array,y_array,n_pts=10):
      
      # This functon takes a generic curve and fits n linear segments through 
      # adaptive interpolation
      
      indices=np.array(np.round(np.linspace(0,np.size(y_array)-1,n_pts,endpoint=True),decimals=0),dtype=int)
      derivative_approx = np.diff(y_array[indices])
      inv_diff=1/np.abs(derivative_approx)
      weight_of_section=inv_diff/np.sum(inv_diff)
      
      total_range=np.max(x_array)-np.min(x_array)
      size_of_section=weight_of_section*total_range
      
      # fitted curve points
      x_array_fit=x_array[0]+np.append([0],np.cumsum(size_of_section))
      y_array_fit=np.interp(x_array_fit,x_array,y_array)
      
      return x_array_fit,y_array_fit

# %%
def convert_capacity_to_sd_sa(cap_curve_disp_shear,part_factor,eigen_vector,weight_vector):
      
      # This function converts the capacity curve in topDisp (m) vs baseShear (kN)
      # into sd vs sa
      
      phi_roof=eigen_vector[0] # 1st item of the eigen vector is the roof
      
      no_capacity_lines=np.size(cap_curve_disp_shear,0)
      
      capacity_array=np.zeros([no_capacity_lines,2]) # array to store sds and sas
      
      alpha1=((np.dot(weight_vector,eigen_vector)/9.81)**2)/((np.sum(weight_vector)/9.81)*np.dot(weight_vector,eigen_vector**2)/9.81)
      
      for i in range(no_capacity_lines):
            
            capacity_array[i,0]=cap_curve_disp_shear[i,0]/(part_factor*phi_roof)
            capacity_array[i,0]=(cap_curve_disp_shear[i,1]/np.sum(weight_vector))/alpha1
      
      return capacity_array
# %%
def calculate_part_factor(mass_vector,eigen_vector):
      
      part_factor=np.dot(mass_vector,eigen_vector)/(np.dot(mass_vector,eigen_vector**2))
      
      return part_factor

# %%

