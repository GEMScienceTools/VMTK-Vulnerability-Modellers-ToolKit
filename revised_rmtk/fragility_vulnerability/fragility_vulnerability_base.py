# -*- coding: utf-8 -*-
"""
Created on Mon Oct 21 15:29:54 2019

@author: LuisMartins
"""

import numpy as np
from scipy import integrate, optimize, stats
from scipy.stats import norm
import math 
import os

# %%
class Fragility:
      
      # The fragility object is defined by its IM and damage states
      
      def __init__(self,IM,damage_state,type_of_curve,regression_model):
            
            # IM - instensity measure
            # damage_state - damage states of the frag model
            # type_of_curve - continuous vs discrete
            # regression model (eg. lognornal)
            self.IM=None
            self.damage_state=None
            self.type_of_curve=None
            self.regression_model=None
            
      @property
      def IM(self):
            return self.IM
      
      @property
      def damage_state(self):
            return self.damage_state
      
      @property
      def type_of_curve(self):
            return self.type_of_curve
      
      @property
      def regression_model(self):
            return self.regression_model
      
# %%
class Vulnerability:
      
      # The fragility object is defined by its IM and damage states
      
      def __init__(self,IM,uncertainty):
            self.IM=None
            self.uncertainty=None
            
      @property
      def IM(self):
            return self.IM
      
      @property
      def uncertainty(self):
            return self.uncertainty
      
# %%
def calculate_sigma_loss(mean_loss_ratio):
      
      # calculates the sigma in loss estimates according to:
      # Silva, V. (2019) Uncertainty and correlation in seismic vulnerability 
      # functions of building classes. Earthquake Spectra. 
      # DOI: 10.1193/013018eqs031m.
      
      if mean_loss_ratio==0:
            sigma_loss_ratio=np.array([0])
      elif mean_loss_ratio==1:
            sigma_loss_ratio=np.array([1])
      else:
            sigma_loss_ratio=np.sqrt(mean_loss_ratio*(-0.7-2*mean_loss_ratio+np.sqrt(6.8*mean_loss_ratio+0.5)))
            
      # calculates a and b parameters for beta distribution
      
      a_beta_dist=((1-mean_loss_ratio)/sigma_loss_ratio**2-(1/mean_loss_ratio))*mean_loss_ratio**2
      b_beta_dist=a_beta_dist*((1/mean_loss_ratio)-1)
      
      return sigma_loss_ratio,a_beta_dist,b_beta_dist

# %%
def fragility_censored_cloud_analysis(imls,edps,damage_thresholds,censored_limit):
      
      x_array=np.log(imls)
      y_array=np.log(edps)
      
      # checks if the y value is above the censored limit
      bool_is_censored=y_array>=censored_limit
      bool_is_not_censored=y_array<censored_limit
      
      # creates an array where all the censored values are set to the limit
      observed=(y_array*bool_is_not_censored)+(censored_limit*bool_is_censored)
      
      def func(x):
            p = np.array([stats.norm.pdf(observed[i], loc=x[1]+x[0]*x_array[i], scale=x[2]) for i in range(len(observed))],dtype=float)
            return -np.sum(np.log(p))
      sol1=optimize.fmin(func,[1,1,1],disp=False)
      
      def func2(x):
            p1 = np.array([stats.norm.pdf(observed[i], loc=x[1]+x[0]*x_array[i], scale=x[2]) for i in range(len(observed)) if bool_is_censored[i]==0],dtype=float)
            p2 = np.array([1-stats.norm.cdf(observed[i], loc=x[1]+x[0]*x_array[i], scale=x[2]) for i in range(len(observed)) if bool_is_censored[i]==1],dtype=float)
            return -np.sum(np.log(p1))-np.sum(np.log(p2))
      
      p_cens=optimize.fmin(func2,[sol1[0],sol1[1],sol1[2]],disp=False)
      
      sigma_edp=math.sqrt(p_cens[2]**2+0.3**2)
      
      sse=np.empty([len(y_array),1])
      ssto=np.empty([len(y_array),1])
      for i in range(len(y_array)):
          sse[i]=(y_array[i]-(p_cens[0]*x_array[i]+p_cens[1]))**2
          ssto[i]=(y_array[i]-np.mean(y_array,dtype=float))**2
      
      r_square=np.ones(len(damage_thresholds))*(1-(np.sum(sse)/np.sum(ssto)))
      
      probability_damage_state=np.zeros([len(x_array),len(damage_thresholds)])
      for i in range(len(x_array)):
            mu=p_cens[0]*x_array[i]+p_cens[1]
            for j in range(len(damage_thresholds)):
                  probability_damage_state[i][j]=1-(stats.norm.cdf(math.log(damage_thresholds[j]),loc=mu,scale=sigma_edp))
      
      return probability_damage_state,r_square

# %%
def calculate_vul_curve(imls,probability_damage_state,consequence_model):
      
      if len(consequence_model)!=np.size(probability_damage_state,1):
            raise Exception('Mismatch between the fragility consequence models!')
      
      if len(imls)!=np.size(probability_damage_state,0):
            raise Exception('Mismatch between the number of IMLs and fragility models!')
      
      vul_curve_array=np.zeros([len(imls),np.size(probability_damage_state,1)])
      for i in range(len(imls)):
            for j in range(np.size(probability_damage_state,1)):
                  if j==np.size(probability_damage_state,1):
                        vul_curve_array[i,j]=vul_curve_array[i,j]+probability_damage_state[i,j]*consequence_model[j]
                  else:
                        vul_curve_array[i,j]=vul_curve_array[i,j]+(probability_damage_state[i,j]-probability_damage_state[i,j+1])*consequence_model[j]
      
      return vul_curve_array