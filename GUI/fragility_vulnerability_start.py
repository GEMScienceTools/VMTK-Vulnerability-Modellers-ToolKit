# -*- coding: utf-8 -*-
"""
Created on Mon Oct 21 15:29:54 2019

@author: LuisMartins
"""

import numpy as np
from scipy import integrate, optimize, stats
from scipy.stats import norm
import math 
import os

# %%
class Fragility:
      
      def __init__(self,IM,damage_states,type_of_curve='discrete',regression_model=None):
            
            # IM - instensity measure
            # damage_state - damage states of the frag model
            # type_of_curve - continuous vs discrete
            # regression model (eg. lognornal)
            self.IM=IM
            self.damage_state=damage_states
            self.type_of_curve=type_of_curve
            self.regression_model=regression_model
            
      
# %%
class Vulnerability:
      
      def __init__(self,IM,loss_ratios,uncertainty):
            self.IM=IM
            self.loss_ratios=loss_ratios
            self.uncertainty=uncertainty
            
            
      
      
# %%
def calculate_sigma_loss(mean_loss_ratio):
      
      # calculates the sigma in loss estimates according to:
      # Silva, V. (2019) Uncertainty and correlation in seismic vulnerability 
      # functions of building classes. Earthquake Spectra. 
      # DOI: 10.1193/013018eqs031m.
      
      if mean_loss_ratio==0:
            sigma_loss_ratio=np.array([0])
      elif mean_loss_ratio==1:
            sigma_loss_ratio=np.array([0])
      else:
            sigma_loss_ratio=np.sqrt(mean_loss_ratio*(-0.7-2*mean_loss_ratio+np.sqrt(6.8*mean_loss_ratio+0.5)))
            
      # calculates a and b parameters for beta distribution
      
      a_beta_dist=((1-mean_loss_ratio)/sigma_loss_ratio**2-(1/mean_loss_ratio))*mean_loss_ratio**2
      b_beta_dist=a_beta_dist*((1/mean_loss_ratio)-1)
      
      return sigma_loss_ratio,a_beta_dist,b_beta_dist

# %%
def fragility_censored_cloud_analysis(imls,edps,damage_thresholds,censored_limit,sigma_build2build=0.3):
      
      x_array=np.log(imls)
      y_array=edps
      
      # checks if the y value is above the censored limit
      bool_is_censored=y_array>=censored_limit
      bool_is_not_censored=y_array<censored_limit
      
      # creates an array where all the censored values are set to the limit
      observed=np.log((y_array*bool_is_not_censored)+(censored_limit*bool_is_censored))
      
      y_array=np.log(edps)
      
      def func(x):
            p = np.array([stats.norm.pdf(observed[i], loc=x[1]+x[0]*x_array[i], scale=x[2]) for i in range(len(observed))],dtype=float)
            return -np.sum(np.log(p[p!= 0]))
      sol1=optimize.fmin(func,[1,1,1],disp=False)
      
      def func2(x):
            p1 = np.array([stats.norm.pdf(observed[i], loc=x[1]+x[0]*x_array[i], scale=x[2]) for i in range(len(observed)) if bool_is_censored[i]==0],dtype=float)
            p2 = np.array([1-stats.norm.cdf(observed[i], loc=x[1]+x[0]*x_array[i], scale=x[2]) for i in range(len(observed)) if bool_is_censored[i]==1],dtype=float)
            return -np.sum(np.log(p1[p1 != 0]))-np.sum(np.log(p2[p2 != 0]))
      
      p_cens=optimize.fmin(func2,[sol1[0],sol1[1],sol1[2]],disp=False)
      
      sigma_edp=math.sqrt(p_cens[2]**2+sigma_build2build**2)
      
      sse=np.empty([len(y_array),1])
      ssto=np.empty([len(y_array),1])
      for i in range(len(y_array)):
          sse[i]=(y_array[i]-(p_cens[0]*x_array[i]+p_cens[1]))**2
          ssto[i]=(y_array[i]-np.mean(y_array,dtype=float))**2
      
      r_square=np.ones(len(damage_thresholds))*(1-(np.sum(sse)/np.sum(ssto)))
      
      x_vec=np.linspace(np.log(0.5*np.min(imls)),np.log(np.max(imls)*2.0),endpoint=True)
      probability_damage_state=np.zeros([len(x_vec),len(damage_thresholds)])
      for i in range(len(x_vec)):
            mu=p_cens[0]*x_vec[i]+p_cens[1]
            for j in range(len(damage_thresholds)):
                  probability_damage_state[i][j]=1-(stats.norm.cdf(np.log(damage_thresholds[j]),loc=mu,scale=sigma_edp))
      
      return np.exp(x_vec),probability_damage_state,r_square

# %%
def calculate_vul_curve_dam_to_loss(imls,probability_damage_state,consequence_model):
      
      if len(consequence_model)!=np.size(probability_damage_state,1):
            raise Exception('Mismatch between the fragility consequence models!')
      
      if len(imls)!=np.size(probability_damage_state,0):
            raise Exception('Mismatch between the number of IMLs and fragility models!')
      
      loss_array=np.zeros([len(imls),1])
      for i in range(len(imls)):
            for j in range(0,np.size(probability_damage_state,1)):
                  if j==(np.size(probability_damage_state,1)-1):
                        loss_array[i,0]=loss_array[i,0]+probability_damage_state[i,j]*consequence_model[j]
                  else:
                        loss_array[i,0]=loss_array[i,0]+(probability_damage_state[i,j]-probability_damage_state[i,j+1])*consequence_model[j]
                        
      vul_curve=np.column_stack((imls,loss_array))
      vul_curve_array=vul_curve[vul_curve[:,0].argsort()]
      
      return vul_curve_array


#%%
def calculate_vul_curve_edps_to_loss(imls,edps,consequence_model,damage_thresholds):
      
      if len(consequence_model)!=len(damage_thresholds):
            raise Exception('Mismatch between the damage thresholds and consequence models!')
            
      struct_dam_linear_thresholds=np.zeros([len(damage_thresholds)+3])
      
      for i in range(1,len(damage_thresholds)+3):
            if i==1:
                  struct_dam_linear_thresholds[i]=(damage_thresholds[i-1])
            elif i<=len(damage_thresholds):
                  struct_dam_linear_thresholds[i]=(damage_thresholds[i-1]+damage_thresholds[i-2])/2
            elif i==len(damage_thresholds)+1:
                  struct_dam_linear_thresholds[i]=(damage_thresholds[-1])
            else:
                  struct_dam_linear_thresholds[i]=damage_thresholds[-1]+(damage_thresholds[-1]+damage_thresholds[-2])/2
                  
      consequence_model_linear=list(consequence_model)
      consequence_model_linear.insert(0,0)
      consequence_model_linear.insert(0,0)
      consequence_model_linear.append(1)
      
      loss_array=np.interp(edps,struct_dam_linear_thresholds,np.array(consequence_model_linear))
      vul_curve=np.column_stack((imls,loss_array))
      vul_curve_array=vul_curve[vul_curve[:,0].argsort()]

      
      return vul_curve_array
#%%
def residual_lognormal_dist(coeffs, imls, fractions):

    mu = coeffs[0]
    sigma = coeffs[1]
    residual = abs(np.array(fractions) - stats.lognorm.cdf(imls, sigma, scale = math.exp(mu)))

    return residual

def get_logmean_logstddev(imls_array,poes_loss_ratio_array):
      
      x_vec=imls_array
      y_vec=poes_loss_ratio_array
      solution, _ = optimize.leastsq(residual_lognormal_dist,[0.1, 0.6],args=(x_vec, y_vec))
      logmean=solution[0]
      logstddev=solution[1]
      
      return logmean, logstddev
#%%

def write_frag_xml(filename,imls,poes_matrix,imt):
    
    startText = ['<?xml version="1.0" encoding="UTF-8"?>', 
                '<nrml xmlns="http://openquake.org/xmlns/nrml/0.5">',
                '<fragilityModel id="fragility_model" assetCategory="buildings" lossCategory="structural">',
                '<description> fragility model </description>']
    
    endText = ['\n</fragilityModel>\n', '</nrml>\n']
    
    damage_states=['DS'+str(i+1) for i in range(poes_matrix.shape[1])]
    
    outFile = open(filename, 'w')
    outFile.writelines("%s\n" % text for text in startText)
    
    outFile.write('\n<limitStates>')
    outFile.writelines("%s " % ds for ds in damage_states)
    outFile.write('</limitStates>\n')
    
    ID='Fragility_curve'
    
    outFile.write('\n<fragilityFunction id="%s" format="discrete">\n' % ID)
    outFile.write('<imls imt="%s" noDamageLimit="0.05"> ' % imt)
    outFile.writelines('%g ' % iml for iml in imls)
    outFile.write(' </imls>\n')
    
    for i in range(len(damage_states)):
          outFile.write('<poes ls="%s"> ' % damage_states[i])
          outFile.writelines('%g ' % poe for poe in poes_matrix[:,i])
          outFile.write(' </poes>\n')
    
    outFile.write('</fragilityFunction>\n')
    endText = ['\n</fragilityModel>\n', '</nrml>\n']
    outFile.writelines('%s' % text for text in endText)
    outFile.close()
    
    return True

def write_vul_xml(filename,imls,loss_ratios,imt,uncert):
    
    startText = ['<?xml version="1.0" encoding="UTF-8"?>', 
          '<nrml xmlns="http://openquake.org/xmlns/nrml/0.5">',
          '<vulnerabilityModel id="vulnerability_model" assetCategory="buildings" lossCategory="structural">',
          '<description> vulnerability model</description>']
    
    endText = ['\n</vulnerabilityModel>\n', '</nrml>\n']
    
    outFile = open(filename, 'w')
    outFile.writelines("%s\n" % text for text in startText)
    
    ID='Vulnerability_curve'
    
    cov_loss=np.zeros(loss_ratios.shape)
    
    if uncert:
          for i in range(loss_ratios.shape[0]):
                mean_loss_ratio=loss_ratios[i]
                sigma_loss,_,_=calculate_sigma_loss(mean_loss_ratio)
                cov_loss[i]=sigma_loss/mean_loss_ratio
                
    outFile.write('\n<vulnerabilityFunction id="%s" dist="BT">\n' % ID)      
    outFile.write('<imls imt="%s" > ' % imt)
    outFile.writelines('%g ' % iml for iml in imls)
    outFile.write(' </imls>\n')
    outFile.write('<meanLRs>')
    outFile.writelines('%g ' % lrs for lrs in loss_ratios)
    outFile.write(' </meanLRs>\n')
    outFile.write('<covLRs>')
    outFile.writelines('%g ' % cv for cv in cov_loss)
    outFile.write(' </covLRs>\n')
    outFile.write('</vulnerabilityFunction>\n')
    
    outFile.writelines('%s' % text for text in endText)
    outFile.close()
    
    return True